Notes from discussion on May 20, 2024 at PyCon sprints

build.py is the entrypoint
 - handles module-level logic including figuring out SCCs
   ... note: it is eager; making it lazy would be a huge help for some codebases
 - modulefinder.py is the module tracker
   - it builds a module-level dependency graph
   - find_sources.py has some related logic, especially related to trees and
     packages including namespace packages
   - .. there does exist some finer-grained logic (options.py -> fine_grained_incremental)

fastparse produce nodes

semanal = populates extra info on nodes; sort of like UGE (esp classSummary) + a few other things like type aliases (maybe?)
          ... has some magic to defer logic
          ... has a fixpoint flavor with multiple passes

typeanal = does work similar to semanal but deals specifically with type annotation contexts
          ... has the same deferral mechanisms


checker = the core type checker at a high level
- binder is most of the control flow
  - Unlike in pyright, this is inside the checker
- checkexpr does a lot of the work
  - checkmember is a lot of the AttributeResolution layer logic, and ~half of the "net" checkexpr logic

- solve + constraints has a lot of the "interesting" stuff:
  - bidirectional inference
  - the constraint solving
... Shantanu says this is nice code, which is good news for me since this is the stuff I most
need to learn for Pyre. I should probably look at it in a great deal of detail.
  - type_state is global state, it has things like global options
  - "type context" is the thing that stores contextual info for the bidirectional solver;
    often it's an implicit idea rather than an actual code artifact; `Context` is just
    an AST node and is *not* the "type context"

- applytype and exapandtype are related to type variable handling

misc
  - PartialType is how mypy handles things like empty containers
    - note: type errors on usage don't happen on usage, they get lifted to the definition
      as needs-annotation... this is a nice behavior! More of this in Pyre might help.
  - plugins... not that interesting to me now but someday it would be good to look at
  - there's an uninitialized local, done as a separate analysis as in Pyre. Consensus
    was that it actually would be nice to do it in the type check, possibly by having
    an actual unbound type (pyanalyze does this and Jelle says it's nice)
  - `if 2 in arg_pass_nums` of `checkexpr.py` is related to lambdas somehow
  - Shantanu: the way Pyright infers function types (as generic types!) is *extremely*
    friendly for scripting use cases. My opinion: Pyre having a mode to do this would
    be extremely helpful for AI use cases that aren't super typing-forward.
  - erasetype.py: ?? Probably related to generics in some way
  - Shantanu: mypy's overload logic is complicated... `check_overload_call`
    - the ambiguous handling (under elif any_causes_overload_ambiguity) is "super sketchy"
    - Carl: intersection types might help with doing this better
  - Mypy intersection logic is maybe involving synthesizing typeinfos
    - in checker.py there's an `intersect_instances` function, logic is there
  - TypeOfAny is nice, it tracks things about the orgin of an Any type (I want to do this
    in Pyre, like if we have an Any from a not-found import don't forget the thing's name)